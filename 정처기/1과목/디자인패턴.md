# 디자인패턴(Design Pattern)
각 모듈의 세분화된 역할 or 모듈들 간 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

### 특징
1. 재사용 가능한 기본형 코드들이 포함되어 있음
2. 개발 과정 중 문제가 발생하면 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
3. 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화
4. 1995년 GoF가 처음으로 구체화 및 체계화
5. GoF의 디자인 패턴은 가장 일반적 사례에 적용될 수 있는 패턴들을 분류하여 정리함

## 생성패턴(Creational Pattern)
객체의 생성과 관련된 패턴 <br>
객체의 생성,참조과정을 캡슐화 >객체가 생성,변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 유연성을 더해줌

### 추상팩토리(Abstract Factory)
- 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능

### 빌더(Builder)
- 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
- 객체의 생성 과정과 표현 방법을 분리 > 동일 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음

### 팩토리 메소드(Factory Method)
- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의, 실제 생성은 서브 클래스가 담당

### 프로토타입(Prototype)
- 원본 객체를 복제하는 방법으로 객체 생성하는 패턴
- 비용이 큰 경우 주로 이용

### 싱글톤(Singleton)
- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조 가능, 여러 프로세스가 동시에 참조할 수는 없음
- 클래스 내에 인스턴스가 하나뿐임을 보장. 불필요한 메모리 낭비를 최소화 가능


## 구조패턴(Structural Pattern)
클래스나 객체를 조합해 더 큰 구조로 만들 수 있게 해주는 패턴<br>
구조가 복잡한 시스템을 개발하기 쉽게 도와줌

### 어댑터(Adapter)
- 호환성 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 인터페이스가 일치하지 않을 때 이용

### 브리지(Bridge)
- 구현부에서 추상층을 분리 > 서로 독립적으로 확장할 수 있도록 구성한 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현

### 컴포지트(Composite)
- 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
- 복합 객체 안에 복합 객체가 포함되는 구조를 구현 가능

### 데코레이터(Decorator)
- 객체 간 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
- 임의의 객체에 부가적 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

### 퍼싸드(Facade)
- 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요

### 플라이웨이트(Flyweight)
- 가능한 한 공유에서 사용함으로써 메모리를 절약하는 패턴
- 다수의 유사 객체를 생성하거나 조작할 때 유용

### 프록시(Proxy)
- 접근 어려운 객체와 여기에 연결하려는 객체 사이에 인터페이스 역할을 수행하는 패턴
- 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용

## 행위패턴(Behavioral Pattern)
클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴<br>
하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와줌

### 책임연쇄(Chain of Responsibility)
- 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
### 커맨드(Command)
- 요청을 객체 형태로 캡슐화 > 재이용하거나 취소할 수 있도록 요청에 필요 정보를 저장하거나 로그를 남기는 패턴
- 요청에 사용되는 각종 명령어들을 추상 클래스(인스턴스 생성 불가)와 구체 클래스로 분리, 단순화
### 인터프리터(Interpreter)
- 언어에 문법 표현을 정의하는 패턴
- SQL, 통신 프로토콜 같은 것 개발 시
### 반복자(Iterator)
- 접근 잦은 객체에 대해 동일 인터페이스를 사용하도록 하는 패턴
- 내부 표현 방법의 노출 없이 순차적 접근이 가능
### 중재자(Mediator)
- 수많은 객체들 간 복잡한 상호작용을 캡슐화 > 객체로 정의하는 패턴
- 객체 사이의 의존성 줄여 결합도를 감소시킬 수 있음
### 메멘토(Memento)
- 특정 시점에서의 객체 내부 상태를 객체화함 > 요청에 따라 해당 시점의 상태로 돌릴 수 있는 기능을 제공
- 되돌리기 기능 같은 것 개발 시
### 옵서버(Observer)
- 한 객체의 상태가 변화하면 객체에 상속된 다른 객체들에게 변화된 상태를 전달하는 패턴
- 분산된 시스템 간 이벤트를 생성, 발행하고 이를 수신해야 할 때 이용
### 상태(State)
- 상태에 따라 동일 동작을 다르게 처리해야 할 때
- 객체 상태를 캡슐화하고 이를 참조하는 방식으로
### 전략(Strategy)
- 동일 계열 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 클라이언트) 원하는 알고리즘을 선택하여 상요 가능 / 클라이언트에 영향 없이 알고리즘 변경 가능
### 템플릿 메소드(Template Method)
- 상위 클래스) 골격 정의 / 하위 클래스) 세부 처리를 구체화하는 구조의 패턴
- 유사 서브 클래스를 묶어 공통된 내용을 사우이 클래스로 정의함 > 코드 양 줄이고, 유지보수를 용이하게 함
### 방문자(Visitor)
- 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
- 분리된 처리 기능은 각 클래스를 방문하여 수행

